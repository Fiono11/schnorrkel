//! Implementation of the Olaf protocol (<https://eprint.iacr.org/2023/899>), which is composed of the Distributed
//! Key Generation (DKG) protocol SimplPedPoP and the Threshold Signing protocol FROST.

use core::cmp::Ordering;

use alloc::vec::Vec;
use curve25519_dalek::{constants::RISTRETTO_BASEPOINT_POINT, traits::Identity, RistrettoPoint, Scalar};
use crate::PublicKey;

use self::{polynomials::CoefficientCommitment, simplpedpop::errors::DKGError};

pub mod simplpedpop;
pub mod frost;
mod polynomials;

const MINIMUM_THRESHOLD: u16 = 2;
const GENERATOR: RistrettoPoint = RISTRETTO_BASEPOINT_POINT;

/// The group public key generated by a trusted dealer or a DKG protocol like SimplPedPoP.
pub type GroupPublicKey = PublicKey;
/// The share of the group public key, which corresponds to the total secret share commitment of the secret sharing scheme.
pub type GroupPublicKeyShare = CoefficientCommitment;

/// The identifier of a participant in the Olaf protocol.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct Identifier(pub(crate) Scalar);

impl PartialOrd for Identifier {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Identifier {
    fn cmp(&self, other: &Self) -> Ordering {
        let serialized_self = self.0.as_bytes();
        let serialized_other = other.0.as_bytes();

        // The default cmp uses lexicographic order; so we need the elements in big endian
        serialized_self
            .as_ref()
            .iter()
            .rev()
            .cmp(serialized_other.as_ref().iter().rev())
    }
}

impl TryFrom<u16> for Identifier {
    type Error = OlafError;

    fn try_from(n: u16) -> Result<Identifier, Self::Error> {
        if n == 0 {
            Err(OlafError::InvalidIdentifier)
        } else {
            // Classic left-to-right double-and-add algorithm that skips the first bit 1 (since
            // identifiers are never zero, there is always a bit 1), thus `sum` starts with 1 too.
            let one = Scalar::ONE;
            let mut sum = Scalar::ONE;

            let bits = (n.to_be_bytes().len() as u32) * 8;
            for i in (0..(bits - n.leading_zeros() - 1)).rev() {
                sum = sum + sum;
                if n & (1 << i) != 0 {
                    sum += one;
                }
            }
            Ok(Self(sum))
        }
    }
}

impl TryFrom<Scalar> for Identifier {
    type Error = DKGError;

    fn try_from(value: Scalar) -> Result<Self, Self::Error> {
        Ok(Self(value))
    }
}

pub(super) fn sum_commitments(
    commitments: &[&Vec<RistrettoPoint>],
) -> Result<Vec<RistrettoPoint>, DKGError> {
    let mut group_commitment =
        vec![
            RistrettoPoint::identity();
            commitments.first().ok_or(DKGError::IncorrectNumberOfCommitments)?.len()
        ];
    for commitment in commitments {
        for (i, c) in group_commitment.iter_mut().enumerate() {
            *c += commitment.get(i).ok_or(DKGError::IncorrectNumberOfCommitments)?;
        }
    }
    Ok(group_commitment)
}

pub enum OlafError {
    /// Identifier cannot be a zero scalar.
    InvalidIdentifier,
}
