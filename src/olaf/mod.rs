//! Implementation of the Olaf protocol (<https://eprint.iacr.org/2023/899>), which is composed of the Distributed
//! Key Generation (DKG) protocol SimplPedPoP and the Threshold Signing protocol FROST.

use alloc::vec::Vec;
use curve25519_dalek::{constants::RISTRETTO_BASEPOINT_POINT, traits::Identity, RistrettoPoint};
use crate::PublicKey;

use self::{polynomials::CoefficientCommitment, simplpedpop::errors::DKGError};

pub mod simplpedpop;
pub mod frost;
mod polynomials;

const MINIMUM_THRESHOLD: u16 = 2;
const GENERATOR: RistrettoPoint = RISTRETTO_BASEPOINT_POINT;

/// The group public key generated by a trusted dealer or a DKG protocol like SimplPedPoP.
pub type GroupPublicKey = PublicKey;
/// The share of the group public key, which corresponds to the total secret share commitment of the secret sharing scheme.
pub type GroupPublicKeyShare = CoefficientCommitment;

pub(super) fn sum_commitments(
    commitments: &[&Vec<RistrettoPoint>],
) -> Result<Vec<RistrettoPoint>, DKGError> {
    let mut group_commitment =
        vec![
            RistrettoPoint::identity();
            commitments.first().ok_or(DKGError::IncorrectNumberOfCommitments)?.len()
        ];
    for commitment in commitments {
        for (i, c) in group_commitment.iter_mut().enumerate() {
            *c += commitment.get(i).ok_or(DKGError::IncorrectNumberOfCommitments)?;
        }
    }
    Ok(group_commitment)
}
