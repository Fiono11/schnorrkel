//! Olaf keys and key shares.

use super::{
    errors::FROSTError,
    identifier::Identifier,
    polynomial::CoefficientCommitment,
    simplpedpop::{SecretPolynomialCommitment, TotalSecretShare},
};
use crate::PublicKey;
use alloc::{
    collections::{BTreeMap, BTreeSet},
    vec::Vec,
};
use derive_getters::Getters;
use zeroize::ZeroizeOnDrop;

/// The group public key generated by the SimplPedPoP protocol.
pub type GroupPublicKey = PublicKey;
/// The group public key share of each participant in the SimplPedPoP protocol.
pub type GroupPublicKeyShare = CoefficientCommitment;

pub(crate) type SigningShare = TotalSecretShare;
pub(crate) type VerifyingShare = GroupPublicKeyShare;
pub(crate) type VerifyingKey = GroupPublicKey;

/// A FROST keypair, which is generated by the SimplPedPoP protocol.
#[derive(Clone, Debug, Getters, ZeroizeOnDrop)]
pub struct KeyPackage {
    /// Denotes the participant identifier each secret share key package is owned by.
    #[zeroize(skip)]
    pub(crate) identifier: Identifier,
    /// This participant's signing share. This is secret.
    pub(crate) signing_share: SigningShare,
    /// This participant's public key.
    #[zeroize(skip)]
    pub(crate) verifying_share: VerifyingShare,
    /// The public key that represents the entire group.
    #[zeroize(skip)]
    pub(crate) verifying_key: VerifyingKey,
    pub(crate) min_signers: u16,
}

impl KeyPackage {
    /// Create a new [`KeyPackage`] instance.
    pub fn new(
        identifier: Identifier,
        signing_share: SigningShare,
        verifying_share: VerifyingShare,
        verifying_key: VerifyingKey,
        min_signers: u16,
    ) -> Self {
        Self { identifier, signing_share, verifying_share, verifying_key, min_signers }
    }
}

/// Public data that contains all the signers' verifying shares as well as the
/// group verifying key.
///
/// Used for verification purposes before publishing a signature.
#[derive(Clone, Debug, Getters)]
pub struct PublicKeyPackage {
    /// The verifying shares for all participants. Used to validate signature
    /// shares they generate.
    pub(crate) verifying_shares: BTreeMap<Identifier, VerifyingShare>,
    /// The joint public key for the entire group.
    pub(crate) verifying_key: VerifyingKey,
}

impl PublicKeyPackage {
    /// Create a new [`PublicKeyPackage`] instance.
    pub fn new(
        verifying_shares: BTreeMap<Identifier, VerifyingShare>,
        verifying_key: VerifyingKey,
    ) -> Self {
        Self { verifying_shares, verifying_key }
    }

    /// Computes the public key package given a list of participant identifiers
    /// and a [`VerifiableSecretSharingCommitment`]. This is useful in scenarios
    /// where the commitments are published somewhere and it's desirable to
    /// recreate the public key package from them.
    pub fn from_commitment(
        identifiers: &BTreeSet<Identifier>,
        commitment: &mut SecretPolynomialCommitment,
    ) -> Result<PublicKeyPackage, FROSTError> {
        let verifying_keys: BTreeMap<_, _> =
            identifiers.iter().map(|id| (*id, commitment.evaluate(&id.0))).collect();
        Ok(PublicKeyPackage::new(
            verifying_keys,
            VerifyingKey::from_point(*commitment.coefficients_commitments.first().unwrap()),
        ))
    }

    /// Computes the public key package given a map of participant identifiers
    /// and their [`VerifiableSecretSharingCommitment`] from a distributed key
    /// generation process. This is useful in scenarios where the commitments
    /// are published somewhere and it's desirable to recreate the public key
    /// package from them.
    pub fn from_dkg_commitments(
        commitments: &BTreeMap<Identifier, SecretPolynomialCommitment>,
    ) -> Result<PublicKeyPackage, FROSTError> {
        let identifiers: BTreeSet<_> = commitments.keys().copied().collect();
        let commitments: Vec<&SecretPolynomialCommitment> = commitments.values().collect();
        let mut group_commitment =
            super::polynomial::PolynomialCommitment::sum_polynomial_commitments(&commitments[..]);
        Self::from_commitment(&identifiers, &mut group_commitment)
    }
}
